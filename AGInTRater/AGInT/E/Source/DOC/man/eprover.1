.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.29.
.TH E "1" "August 2009" "E 1.1 Balasun" "User Commands"
.SH NAME
E \- manual page for E 1.1 Balasun
.SH SYNOPSIS
.B eprover
[\fIoptions\fR] [\fIfiles\fR]
.SH DESCRIPTION
E 1.1 "Balasun"
.PP
Read a set of first-order clauses and formulae and try to refute it.
.SH OPTIONS

.HP
\fB\-h\fR
.HP
\fB\-\-help\fR
.IP
Print a short description of program usage and options.
.HP
\fB\-V\fR
.HP
\fB\-\-version\fR
.IP
Print the version number of the prover. Please include this with all bug
reports (if any).
.HP
\fB\-v\fR
.HP
\fB\-\-verbose[=\fR<arg>]
.IP
Verbose comments on the progress of the program. This differs from the
output level (below) in that technical information is printed to stderr,
while the output level determines which logical manipulations of the
clauses are printed to stdout. The short form or the long form without
the optional argument is equivalent to \fB\-\-verbose\fR=\fI1\fR.
.HP
\fB\-o\fR <arg>
.HP
\fB\-\-output\-file=\fR<arg>
.IP
Redirect output into the named file.
.HP
\fB\-s\fR
.HP
\fB\-\-silent\fR
.IP
Equivalent to \fB\-\-output\-level\fR=\fI0\fR.
.HP
\fB\-l\fR <arg>
.HP
\fB\-\-output\-level=\fR<arg>
.IP
Select an output level, greater values imply more verbose output. Level 0
produces nearly no output, level 1 will output each clause as it is
processed, level 2 will output generating inferences, level 3 will give a
full protocol including rewrite steps and level 4 will include some
internal clause renamings. Levels >= 2 also imply PCL2 or TSTP formats
(which can be post-processed with suitable tools).
.HP
\fB\-\-pcl\-terms\-compressed\fR
.IP
Print terms in the PCL output in shared representation.
.HP
\fB\-\-pcl\-compact\fR
.IP
Print PCL steps without additional spaces for formatting (safes disk
space for large protocols).
.HP
\fB\-\-print\-statistics\fR
.IP
Print the inference statistics (only relevant for output level 0,
otherwise they are printed automatically.
.HP
\fB\-\-print\-detailed\-statistics\fR
.IP
Print data about the proof state that is potentially expensive to
collect. Includes number of term cells and number of rewrite steps.
.HP
\fB\-S\fR
.HP
\fB\-\-print\-saturated[=\fR<arg>]
.IP
Print the (semi-) saturated clause sets after terminating the saturation
process. The argument given describes which parts should be printed in
which order. Legal characters are 'eigEIGaA', standing for processed
positive units, processed negative units, processed non-units,
unprocessed positive units, unprocessed negative units, unprocessed
non-units, and two types of additional equality axioms, respectively.
Equality axioms will only be printed if the original specification
contained real equality. In this case, 'a' requests axioms in which a
separate substitutivity axiom is given for each argument position of a
function or predicate symbol, while 'A' requests a single substitutivity
axiom (covering all positions) for each symbol. The short form or the
long form without the optional argument is equivalent to
\fB\-\-print\-saturated\fR=\fIeigEIG\fR.
.HP
\fB\-\-print\-sat\-info\fR
.IP
Print additional information (clause number, weight, etc) as a comment
for clauses from the semi-saturated end system.
.HP
\fB\-\-filter\-saturated[=\fR<arg>]
.TP
Filter the
(semi-) saturated clause sets after terminating the
.IP
saturation process. The argument is a string describing which operations
to take (and in which order). Options are 'u' (remove all clauses with
more than one literal), 'c' (delete all but one copy of identical
clauses, 'n', 'r', 'f' (forward contraction, unit-subsumption only, no
rewriting, rewriting with rules only, full rewriting, respectively), and
\&'N', 'R' and 'F' (as their lower case counterparts, but with
non-unit-subsumption enabled as well). The option without the optional
argument is equivalent to \fB\-\-filter\-saturated\fR=\fIFc\fR.
.HP
\fB\-\-cnf\fR
.IP
Convert the input problem into clause normal form and print it. This is
(nearly) equivalent to '--print-saturated=eigEIG
\fB\-\-processed\-clauses\-limit\fR=\fI0\fR' and will by default perform some usually
useful simplifications. You can additionally specify e.g.
\&'--no-preprocessing' if you want just the result of CNF translation.
.HP
\fB\-\-print\-pid\fR
.IP
Print the process id of the prover as a comment after option processing.
.HP
\fB\-\-error\-on\-empty\fR
.IP
Return with an error code if the input file contains no clauses.
Formally, the empty clause set (as an empty conjunction of clauses) is
trivially satisfiable, and E will treat any empty input set as
satisfiable. However, in composite systems this is more often a sign that
something went wrong. Use this option to catch such bugs.
.HP
\fB\-m\fR <arg>
.HP
\fB\-\-memory\-limit=\fR<arg>
.IP
Limit the memory the prover may use. The argument is the allowed amount
of memory in MB. If you use the argument 'Auto', the system will try to
figure out the amount of physical memory of your machine and claim most
of it. This option may not work everywhere, due to broken and/or strange
behaviour of setrlimit() in some UNIX implementations, and due to the
fact that I know of no portable way to figure out the physical memory in
a machine. Both the option and the 'Auto' version do work under all
tested versions of Solaris and GNU/Linux. Due to problems with limit
datatypes, it is currently impossible to set a limit of more than 2 GB
(2048 MB).
.HP
\fB\-\-cpu\-limit[=\fR<arg>]
.IP
Limit the cpu time the prover should run. The optional argument is the
CPU time in seconds. The prover will terminate immediately after reaching
the time limit, regardless of internal state. This option may not work
everywhere, due to broken and/or strange behaviour of setrlimit() in some
UNIX implementations. It does work under all tested versions of Solaris,
HP-UX, MacOS-X, and GNU/Linux. As a side effect, this option will inhibit
core file writing. Please note that if you use both \fB\-\-cpu\-limit\fR and
\fB\-\-soft\-cpu\-limit\fR, the soft limit has to be smaller than the hard limit to
have any effect.  The option without the optional argument is equivalent
to \fB\-\-cpu\-limit\fR=\fI300\fR.
.HP
\fB\-\-soft\-cpu\-limit[=\fR<arg>]
.IP
Limit the cpu time the prover should spend in the main saturation phase.
The prover will then terminate gracefully, i.e. it will perform
post-processing, filtering and printing of unprocessed clauses, if these
options are selected. Note that for some filtering options (in particular
those which perform full subsumption), the postprocessing time may well
be larger than the saturation time. This option is particularly useful if
you want to use E as a preprocessor or lemma generator in a larger
system. The option without the optional argument is equivalent to
\fB\-\-soft\-cpu\-limit\fR=\fI290\fR.
.HP
\fB\-R\fR
.HP
\fB\-\-resources\-info\fR
.IP
Give some information about the resources used by the prover. You will
usually get CPU time information. On systems returning more information
with the rusage() system call, you will also get information about memory
consumption.
.HP
\fB\-C\fR <arg>
.HP
\fB\-\-processed\-clauses\-limit=\fR<arg>
.IP
Set the maximal number of clauses to process (i.e. the number of
traversals of the main-loop).
.HP
\fB\-P\fR <arg>
.HP
\fB\-\-processed\-set\-limit=\fR<arg>
.IP
Set the maximal size of the set of processed clauses. This differs from
the previous option in that redundant and back-simplified processed
clauses are not counted.
.HP
\fB\-U\fR <arg>
.HP
\fB\-\-unprocessed\-limit=\fR<arg>
.IP
Set the maximal size of the set of unprocessed clauses. This is a
termination condition, not something to use to control the deletion of
bad clauses. Compare \fB\-\-delete\-bad\-limit\fR.
.HP
\fB\-T\fR <arg>
.HP
\fB\-\-total\-clause\-set\-limit=\fR<arg>
.IP
Set the maximal size of the set of all clauses. See previous option.
.HP
\fB\-n\fR
.HP
\fB\-\-eqn\-no\-infix\fR
.IP
In LOP, print equations in prefix notation equal(x,y).
.HP
\fB\-e\fR
.HP
\fB\-\-full\-equational\-rep\fR
.IP
In LOP. print all literals as equations, even non-equational ones.
.HP
\fB\-\-tptp\-in\fR
.IP
Parse TPTP-2 format instead of E-LOP (but note that includes are handled
according to TPTP-3 semantics).
.HP
\fB\-\-tptp\-out\fR
.IP
Print TPTP format instead of E-LOP. Implies \fB\-\-eqn\-no\-infix\fR and will
ignore \fB\-\-full\-equational\-rep\fR.
.HP
\fB\-\-tptp\-format\fR
.IP
Equivalent to \fB\-\-tptp\-in\fR and \fB\-\-tptp\-out\fR.
.HP
\fB\-\-tptp2\-in\fR
.IP
Synonymous with \fB\-\-tptp\-in\fR.
.HP
\fB\-\-tptp2\-out\fR
.IP
Synonymous with \fB\-\-tptp\-out\fR.
.HP
\fB\-\-tptp2\-format\fR
.IP
Synonymous with \fB\-\-tptp\-format\fR.
.HP
\fB\-\-tstp\-in\fR
.IP
Parse TPTP-3 format instead of E-LOP (Note that TPTP-3 syntax is still
under development, and the version in E may not be fully conforming at
all times. E works on all TPTP 3.0.1 input files (including includes).
.HP
\fB\-\-tstp\-out\fR
.IP
Print output clauses in TPTP-3 syntax. In particular, for output levels
>=2, write derivations as TPTP-3 derivations (default is PCL).
.HP
\fB\-\-tstp\-format\fR
.IP
Equivalent to \fB\-\-tstp\-in\fR and \fB\-\-tstp\-out\fR.
.HP
\fB\-\-tptp3\-in\fR
.IP
Synonymous with \fB\-\-tstp\-in\fR.
.HP
\fB\-\-tptp3\-out\fR
.IP
Synonymous with \fB\-\-tstp\-out\fR.
.HP
\fB\-\-tptp3\-format\fR
.IP
Synonymous with \fB\-\-tstp\-format\fR.
.HP
\fB\-\-no\-preprocessing\fR
.IP
Do not perform preprocessing on the initial clause set. Preprocessing
currently removes tautologies and orders terms, literals and clauses in a
certain ("canonical") way before anything else happens. Unless the next
option is set, it will also unfold equational definitions.
.HP
\fB\-\-eq\-unfold\-limit=\fR<arg>
.IP
During preprocessing, limit unfolding (and removing) of equational
definitions to those where the expanded definiton is at most the given
limit bigger (in terms of standard weight) than the defined term.
.HP
\fB\-\-eq\-unfold\-maxclauses=\fR<arg>
.IP
During preprocessing, don't try unfolding of equational definitions if
the problem has more than this limit of clauses.
.HP
\fB\-\-no\-eq\-unfolding\fR
.IP
During preprocessing, abstain from unfolding (and removing) equational
definitions.
.HP
\fB\-\-rel\-pruning\-level[=\fR<arg>]
.IP
Perform relevancy pruning up to the given level on the unprocessed
axioms. The option without the optional argument is equivalent to
\fB\-\-rel\-pruning\-level\fR=\fI3\fR.
.HP
\fB\-\-presat\-simplify\fR
.IP
Before proper saturation do a complete interreduction of the proof state.
.HP
\fB\-\-ac\-handling[=\fR<arg>]
.IP
Select AC handling mode. Preselected is 'DiscardAll', other options are
\&'None' to disable AC handling, 'KeepUnits', and 'KeepOrientable'. The
option without the optional argument is equivalent to
\fB\-\-ac\-handling\fR=\fIKeepUnits\fR.
.HP
\fB\-\-ac\-non\-aggressive\fR
.IP
Do AC resolution on negative literals only on processing (by default, AC
resolution is done after clause creation). Only effective if AC handling
is not disabled.
.HP
\fB\-W\fR <arg>
.HP
\fB\-\-literal\-selection\-strategy=\fR<arg>
.IP
Choose a strategy for selection of negative literals. There are two
special values for this option: NoSelection will select no literal (i.e.
perform normal superposition) and NoGeneration will inhibit all
generating inferences. For a list of the other (hopefully
self-documenting) values run 'eprover \fB\-W\fR none'. There are two variants of
each strategy. The one prefixed with 'P' will allow paramodulation into
maximal positive literals in addition to paramodulation into maximal
selected negative literals.
.HP
\fB\-\-no\-generation\fR
.IP
Don't perform any generating inferences (equivalent to
\fB\-\-literal\-selection\-strategy\fR=\fINoGeneration\fR).
.HP
\fB\-\-select\-on\-processing\-only\fR
.IP
Perform literal selection at processing time only (i.e. select only in
the _given clause_), not before clause evaluation. This is relevant
because many clause selection heuristics give special consideration to
maximal or selected literals.
.HP
\fB\-i\fR
.HP
\fB\-\-inherit\-paramod\-literals\fR
.IP
Always select the negative literals a previous inference paramodulated
into (if possible). If no such literal exists, select as dictated by the
selection strategy.
.HP
\fB\-j\fR
.HP
\fB\-\-inherit\-goal\-pm\-literals\fR
.IP
In a goal (all negative clause), always select the negative literals a
previous inference paramodulated into (if possible). If no such literal
exists, select as dictated by the selection strategy.
.HP
\fB\-j\fR
.HP
\fB\-\-inherit\-conjecture\-pm\-literals\fR
.IP
In a conjecture-derived clause), always select the negative literals a
previous inference paramodulated into (if possible). If no such literal
exists, select as dictated by the selection strategy.
.HP
\fB\-\-selection\-pos\-min=\fR<arg>
.IP
Set a lower limit for the number of positive literals a clause must have
to be eligible for literal selection.
.HP
\fB\-\-selection\-pos\-max=\fR<arg>
.IP
Set a upper limit for the number of positive literals a clause can have
to be eligible for literal selection.
.HP
\fB\-\-selection\-neg\-min=\fR<arg>
.IP
Set a lower limit for the number of negative literals a clause must have
to be eligible for literal selection.
.HP
\fB\-\-selection\-neg\-max=\fR<arg>
.IP
Set a upper limit for the number of negative literals a clause can have
to be eligible for literal selection.
.HP
\fB\-\-selection\-all\-min=\fR<arg>
.IP
Set a lower limit for the number of literals a clause must have to be
eligible for literal selection.
.HP
\fB\-\-selection\-all\-max=\fR<arg>
.IP
Set an upper limit for the number of literals a clause must have to be
eligible for literal selection.
.HP
\fB\-\-selection\-weight\-min=\fR<arg>
.IP
Set the minimum weight a clause must have to be eligible for literal
selection.
.HP
\fB\-\-prefer\-initial\-clauses\fR
.IP
Always process all initial clauses first.
.HP
\fB\-x\fR <arg>
.HP
\fB\-\-expert\-heuristic=\fR<arg>
.IP
Select one of the clause selection heuristics. Currently at least
available: Auto, Weight, StandardWeight, RWeight, FIFO, LIFO, Uniq,
UseWatchlist. For a full list check HEURISTICS/che_proofcontrol.c. Auto
is recommended if you only want to find a proof. It is special in that it
will also set some additional options. To have optimal performance, you
also should specify \fB\-tAuto\fR to select a good term ordering. LIFO is unfair
and will make the prover incomplete. Uniq is used internally and is not
very useful in most cases. You can define more heuristics using the
option \fB\-H\fR (see below).
.HP
\fB\-\-filter\-limit[=\fR<arg>]
.IP
Set the limit on the number of 'storage units' in the proof state, after
which the set of unprocessed clauses will be filtered against the
processed clauses to eliminate redundant clauses. As of E 0.7, a 'storage
unit' is approximately one byte, however, storage is estimated in an
abstract way, independent of hardware or memory allocation library, and
the storage estimate is only an approximation. The option without the
optional argument is equivalent to \fB\-\-filter\-limit\fR=\fI1000000\fR.
.HP
\fB\-\-filter\-copies\-limit[=\fR<arg>]
.IP
Set the number of storage units in new unprocessed clauses after which
the set of unprocessed clauses will be filtered for equivalent copies of
clauses (see above). As this operation is cheaper, you may want to set
this limit lower than \fB\-\-filter\-limit\fR. The option without the optional
argument is equivalent to \fB\-\-filter\-copies\-limit\fR=\fI800000\fR.
.HP
\fB\-\-delete\-bad\-limit[=\fR<arg>]
.IP
Set the number of storage units after which bad clauses are deleted
without further consideration. This causes the prover to be potentially
incomplete, but will allow you to limit the maximum amount of memory used
fairly well. The prover will tell you if a proof attempt failed due to
the incompleteness introduced by this option. It is recommended to set
this limit significantly higher than \fB\-\-filter\-limit\fR or
\fB\-\-filter\-copies\-limit\fR. If you select \fB\-xAuto\fR and set a memory limit, the
prover will determine a good value automatically. The option without the
optional argument is equivalent to \fB\-\-delete\-bad\-limit\fR=\fI1500000\fR.
.HP
\fB\-\-assume\-completeness\fR
.IP
There are various way (e.g. the next few options) to configure the prover
to be strongly incomplete in the general case. E will detect when such an
option is selected and return corresponding exit states (i.e. it will not
claim satisfiability just because it ran out of unprocessed clauses). If
you _know_ that for your class of problems the selected strategy is still
complete, use this option to tell the system that this is the case.
.HP
\fB\-\-disable\-eq\-factoring\fR
.IP
Disable equality factoring. This makes the prover incomplete for general
non-Horn problems, but helps for some specialized classes. It is not
necessary to disable equality factoring for Horn problems, as Horn
clauses are not factored anyways.
.HP
\fB\-\-disable\-paramod\-into\-neg\-units\fR
.IP
Disable paramodulation into negative unit clause. This makes the prover
incomplete in the general case, but helps for some specialized classes.
.HP
\fB\-\-disable\-given\-clause\-fw\-contraction\fR
.IP
Disable simplification and subsumption of the newly selected given clause
(clauses are still simplified when they are generated). In general, this
breaks some basic assumptions of the DISCOUNT loop proof search
procedure. However, there are some problem classes in which  this
simplifications empirically never occurs. In such cases, we can save
significant overhead. The option _should_ work in all cases, but is not
expected to improve things in most cases.
.HP
\fB\-\-simul\-paramod\fR
.IP
Use simultaneous paramodulation to implement superposition. Default is to
use plain paramodulation. This is an experimental feature.
.HP
\fB\-\-oriented\-simul\-paramod\fR
.IP
Use simultaneous paramodulation for oriented from-literals. This is an
experimental feature.
.HP
\fB\-\-split\-clauses[=\fR<arg>]
.IP
Determine which clauses should be subject to splitting. The argument is
the binary 'OR' of values for the desired classes:
.TP
1:
Horn clauses
.TP
2:
Non-Horn clauses
.TP
4:
Negative clauses
.TP
8:
Positive clauses
.TP
16:
Clauses with both positive and negative literals
.IP
Each set bit adds that class to the set of clauses which will be split.
The option without the optional argument is equivalent to
\fB\-\-split\-clauses\fR=\fI7\fR.
.HP
\fB\-\-split\-method=\fR<arg>
.IP
Determine how to treat ground literals in splitting. The argument is
either '0' to denote no splitting of ground literals (they are all
assigned to the first split clause produced), '1' to denote that all
ground literals should form a single new clause, or '2', in which case
ground literals are treated as usual and are all split off into
individual clauses.
.HP
\fB\-\-split\-aggressive\fR
.IP
Apply splitting to new clauses (after simplification) and before
evaluation. By default, splitting (if activated) is only performed on
selected clauses.
.HP
\fB\-\-split\-reuse\-defs\fR
.IP
If possible, reuse previous definitions for splitting.
.HP
\fB\-\-reweight\-limit[=\fR<arg>]
.IP
Set the number of new unprocessed clauses after which the set of
unprocessed clauses will be reevaluated. The option without the optional
argument is equivalent to \fB\-\-reweight\-limit\fR=\fI30000\fR.
.HP
\fB\-t\fR <arg>
.HP
\fB\-\-term\-ordering=\fR<arg>
.IP
Select an ordering type (currently Auto, LPO, LPO4, KBO or KBO1). \fB\-tAuto\fR
is suggested, in particular with \fB\-xAuto\fR. KBO and KBO1 are different
implementations of the same ordering, KBO is usually faster and has had
more testing. Similarly, LPO4 is an new, equivalent but superior
implementation of LPO.
.HP
\fB\-w\fR <arg>
.HP
\fB\-\-order\-weight\-generation=\fR<arg>
.IP
Select a method for the generation of weights for use with the term
ordering. Run 'eprover \fB\-w\fR none' for a list of options.
.HP
\fB\-\-order\-weights=\fR<arg>
.IP
Describe a (partial) assignments of weights to function symbols for term
orderings (in particular, KBO). You can specify a list of weights of the
form 'f1:w1,f2:w2, ...'. Since a total weight assignment is needed, E
will _first_ apply any weight generation scheme specified (or the default
one), and then modify the weights as specified. Note that E performs only
very basic sanity checks, so you probably can specify weights that break
KBO constraints.
.HP
\fB\-G\fR <arg>
.HP
\fB\-\-order\-precedence\-generation=\fR<arg>
.IP
Select a method for the generation of a precedence for use with the term
ordering. Run 'eprover \fB\-G\fR none' for a list of options.
.HP
\fB\-c\fR <arg>
.HP
\fB\-\-order\-constant\-weight=\fR<arg>
.IP
Set a special weight > 0 for constants in the term ordering. By default,
constants are treated like other function symbols.
.HP
\fB\-\-precedence[=\fR<arg>]
.IP
Describe a (partial) precedence for the term ordering used for the proof
attempt. You can specify a comma-separated list of precedence chains,
where a precedence chain is a list of function symbols (which all have to
appear in the proof problem), connected by >, <, or =. If this option is
used in connection with \fB\-\-order\-precedence\-generation\fR, the partial
ordering will be completed using the selected method, otherwise the
prover runs with a non-ground-total ordering. The option without the
optional argument is equivalent to \fB\-\-precedence=\fR.
.HP
\fB\-\-lpo\-recursion\-limit[=\fR<arg>]
.IP
Set a depth limit for LPO comparisons. Most comparisons do not need more
than 10 or 20 levels of recursion. By default, recursion depth is limited
to 1000 to avoid stack overflow problems. If the limit is reached, the
prover assumes that the terms are uncomparable. Smaller values make the
comparison attempts faster, but less exact. Larger values have the
opposite effect. Values up to 20000 should be save on most operating
systems. If you run into segmentation faults while using LPO or LPO4,
first try to set this limit to a reasonable value. If the problem
persists, send a bug report ;-) The option without the optional argument
is equivalent to \fB\-\-lpo\-recursion\-limit\fR=\fI100\fR.
.HP
\fB\-\-restrict\-literal\-comparisons\fR
.IP
Make all literals uncomparable in the term ordering (i.e. do not use the
term ordering to restrict paramodulation, equality resolution and
factoring to certain literals. This is necessary to make
Set-of-Support-strategies complete for the non-equational case (It still
is incomplete for the equational case, but pretty useless anyways).
.HP
\fB\-\-sos\-uses\-input\-types\fR
.IP
If input is TPTP format, use TPTP conjectures for initializing the Set of
Support. If not in TPTP format, use E-LOP queries (clauses of the form
?-l(X),...,m(Y)). Normally, all negative clauses are used. Please note
that most E heuristics do not use this information at all, it is
currently only useful for certain parameter settings (including the
SimulateSOS priority function).
.HP
\fB\-\-destructive\-er\fR
.IP
Allow destructive equality resolution inferences on pure-variable
literals of the form X!=Y, i.e. replace the original clause with the
result of an equality resolution inference on this literal.
.HP
\fB\-\-strong\-destructive\-er\fR
.IP
Allow destructive equality resolution inferences on literals of the form
X!=t (where X does not occur in t), i.e. replace the original clause with
the result of an equality resolution inference on this literal. Unless I
am brain-dead, this maintains completeness, although the proof is rather
tricky.
.HP
\fB\-\-destructive\-er\-aggressive\fR
.IP
Apply destructive equality resolution to all newly generated clauses, not
just to selected clauses. Implies \fB\-\-destructive\-er\fR.
.HP
\fB\-\-forward\-context\-sr\fR
.IP
Apply contextual simplify-reflect with processed clauses to the given
clause.
.HP
\fB\-\-forward\-context\-sr\-aggressive\fR
.IP
Apply contextual simplify-reflect with processed clauses to new clauses.
Implies \fB\-\-forward\-context\-sr\fR.
.HP
\fB\-\-backward\-context\-sr\fR
.IP
Apply contextual simplify-reflect with the given clause to processed
clauses.
.HP
\fB\-g\fR
.HP
\fB\-\-prefer\-general\-demodulators\fR
.IP
Prefer general demodulators. By default, E prefers specialized
demodulators. This affects in which order the rewrite  index is
traversed.
.HP
\fB\-F\fR <arg>
.HP
\fB\-\-forward_demod_level=\fR<arg>
.IP
Set the desired level for rewriting of unprocessed clauses. A value of 0
means no rewriting, 1 indicates to use rules (orientable equations) only,
2 indicates full rewriting with rules and instances of unorientable
equations. Default behavior is 2.
.HP
\fB\-\-strong\-rw\-inst\fR
.IP
Instantiate unbound variables in matching potential demodulators with a
small constant terms.
.HP
\fB\-u\fR
.HP
\fB\-\-strong\-forward\-subsumption\fR
.IP
Try multiple positions and unit-equations to try to equationally subsume
a single new clause. Default is to search for a single position.
.HP
\fB\-\-watchlist[=\fR<arg>]
.IP
Give the name for a file containing clauses to be watched for during the
saturation process. If a clause is generated that subsumes a watchlist
clause, the subsumed clause is removed from the watchlist. The prover
will terminate when the watchlist is empty. If you want to use the
watchlist for guiding the proof, put the empty clause onto the list and
use the built-in clause selection heuristic 'UseWatchlist' (or build a
heuristic yourself using the priority functions 'PreferWatchlist' and
\&'DeferWatchlist'). Use the argument 'Use inline watchlist type' (or no
argument) and the special clause type 'watchlist' if you want to put
watchlist clauses into the normal input stream. This is only supported
for TPTP input formats. The option without the optional argument is
equivalent to \fB\-\-watchlist=\fR'Use inline watchlist type'.
.HP
\fB\-\-no\-watchlist\-simplification\fR
.IP
Normally, that watchlist is brought into normal form with respect to the
current processed clause set and certain simplifications. This option
disables this behaviour.
.HP
\fB\-\-conventional\-subsumption\fR
.IP
Equivalent to \fB\-\-subsumption\-indexing\fR=\fINone\fR.
.HP
\fB\-\-subsumption\-indexing=\fR<arg>
.IP
Determine choice of indexing for (most) subsumption operations. Choices
are 'None' for naive subsumption, 'Direct' for direct mapped FV-Indexing,
\&'Perm' for permuted FV-Indexing and 'PermOpt' for permuted FV-Indexing
with deletion of (suspected) non-informative features. Default behaviour
is 'Perm'.
.HP
\fB\-\-fvindex\-featuretypes=\fR<arg>
.IP
Select the feature types used for indexing. Choices are "None" to disable
FV-indexing, "AC" for AC compatible features (the default) (literal
number and symbol counts), "SS" for set subsumption compatible features
(symbol depth), and "All" for all features.Unless you want to measure the
effects of the different features, I suggest you stick with the default.
.HP
\fB\-\-fvindex\-maxfeatures[=\fR<arg>]
.IP
Set the maximum initial number of symbols for feature computation.
Depending on the feature selection, a value of X here will convert into
2X+2 features (for set subsumption features), 2X+4 features (for
AC-compatible features) or 4X+6 features (if all features are used, the
default). Note that the actually used set of features may be smaller than
this if the signature does not contain enough symbols.For the Perm and
PermOpt version, this is _also_ used to set the maximum depth of the
feature vector index. Yes, I should probably make this into two separate
options. If you select a small value here, you should probably not use
"Direct" for the \fB\-\-subsumption\-indexing\fR option. The option without the
optional argument is equivalent to \fB\-\-fvindex\-maxfeatures\fR=\fI200\fR.
.HP
\fB\-\-fvindex\-slack[=\fR<arg>]
.IP
Set the number of slots reserved in the index for function symbols that
may be introduced into the signature later, e.g. by splitting. If no new
symbols are introduced, this just wastes time and memory. If PermOpt is
chosen, the slackness slots will be deleted from the index anyways, but
will still waste (a little) time in computing feature vectors. The option
without the optional argument is equivalent to \fB\-\-fvindex\-slack\fR=\fI0\fR.
.HP
\fB\-\-simplify\-with\-unprocessed\-units[=\fR<arg>]
.IP
Determine whether to use unprocessed unit clauses for simplify-reflect
(unit-cutting) and unit subsumption. Possible values are 'NoSimplify' for
strict DISCOUNT loop, 'TopSimplify' to use unprocessed units at the top
level only, or 'FullSimplify' to use positive units even within
equations. The option without the optional argument is equivalent to
\fB\-\-simplify\-with\-unprocessed\-units\fR=\fITopSimplify\fR.
.HP
\fB\-D\fR <arg>
.HP
\fB\-\-define\-weight\-function=\fR<arg>
.TP
Define
a weight function (see manual for details). Later definitions
.IP
override previous definitions.
.HP
\fB\-H\fR <arg>
.HP
\fB\-\-define\-heuristic=\fR<arg>
.IP
Define a clause selection heuristic (see manual for details). Later
definitions override previous definitions.
.HP
\fB\-\-free\-numbers\fR
.IP
Treat numbers (strings of decimal digits) as normal free function symbols
in the input. By default, number now are supposed to denote domain
constants and to be implicitly different from each other.
.HP
\fB\-\-free\-objects\fR
.IP
Treat object identifiers (strings in double quotes) as normal free
function symbols in the input. By default, object identifiers now
represent domain objects and are implicitly different from each other
(and from numbers, unless those are declared to be free).
.HP
\fB\-\-definitional\-cnf[=\fR<arg>]
.IP
Tune the clausification algorithm to introduces definitions for
subformulae to avoid exponential blow-up. The optional argument is a
fudge factor that determines whendefinitions are introduced. 0 disables
definitions completely. The default works well. The option without the
optional argument is equivalent to \fB\-\-definitional\-cnf\fR=\fI24\fR.
.SH "REPORTING BUGS"
.PP
Report bugs to <schulz@eprover.org>. Please include the following, if
possible:
.PP
* The version of the package as reported by \fBeprover \-\-version\fR.
.PP
* The operating system and version.
.PP
* The exact command line that leads to the unexpected behaviour.
.PP
* A description of what you expected and what actually happend.
.PP
* If possible all input files necessary to reproduce the bug.
.SH COPYRIGHT
Copyright \(co 1998-2009 by Stephan Schulz, schulz@eprover.org
.PP
You can find the latest version of E and additional information at
http://www.eprover.org
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License
along with this program (it should be contained in the top level
directory of the distribution in the file COPYING); if not, write to
the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
Boston, MA  02111-1307 USA
.PP
The original copyright holder can be contacted as
.PP
Stephan Schulz (I4)
Technische Universitaet Muenchen
Institut fuer Informatik
Boltzmannstrasse 3
85748 Garching bei Muenchen
Germany
